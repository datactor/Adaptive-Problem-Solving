# What is Computer Science?

정보를 연구하는 학문으로, 어떻게 표현하고 실제로 어떻게 처리하는지와 같은 의미에서
computational thinking은 CS를 우리가 관심있는 문제에 적용하는 것일 뿐이다.
arts, humanities, sciences, social sciences 등과 같이 domain과 상관없이
real-world의 문제에 적용할 수 있는 학문이다.

따라서 CS가 정보에 관한 것이고, 정보와 함께 문제를 해결하는 것이라면 실제로 문제를 해결한다는 것은 무엇일까? 우리가 학습한 레슨과 교훈과 같은 정보들에 대해서 궁극적으로 적용할 수 있는 모델을 정의할 수 있을까?

PS는 `input(problem) -> abstraction(fn solve()) -> output(goal)` 이라고 정의할 수 있다.

`unary`: `unary`라는 단항 operating 단위를 simple symbol로 사용하는 간단한 시스템이다. 이것을 조금 더 mathy하게 만들어보면 `base-1`이라고 할 수 있다(base under which you're operating has one digit in it).

`base-2(binary)`: bi는 2를 의미하므로, 컴퓨터는 2 digits를 마음대로 사용할 수 있다. 즉 `binary digit`은, `bit`의 origin 이라고 할 수 있다(bi~~nary digi~~t). 우리는 손가락을 10개 가진 인간으로서 10을 의미하는 `dec`은 decimal system을 사용한다.

컴퓨터는 어떻게 0과 1을 사용해서 언어를 나타낼까? light bulb를 생각하면 된다.
0을 나타내고 싶을 때는 light switch-off, 1은 switch-on으로 간단하게 생각하면 된다.

우리의 컴퓨터에는 이러한 light bulb(정확히는 transister)들이 수백만개 이상 있다.
즉, 전기의 부재는 0, 존재는 1로 수백만개의 트랜지스터들이 상태를 나타낸다.

`base` terminology is now a little more germane.
즉 `base`는 `power`의 밑을 뜻한다.

`byte`: 우리에게 익숙한 단위인 byte가 많다는 것은, base-2를 8자리로 조합하여 사용하는 단위가 일반적이라는 뜻이다. 즉 컴퓨터는 0을 나타낼 때, 일반적으로 `00000000`로 나타낼 것이다.
여기서 `A`는 65, 즉 `01000001`로이나타내듯이 숫자를 문자로 mapping하는 전체 시스템이 있을 것이다(`American Standard Code for Information Interchange`).
그렇기 때문에 Ascii는 1byte로 해결될 수 있는 것이고, Ascii에 정의되지 않은 많은 문자열은
비용은 비싸지지만, uni-code라는 형태로 2바이트, 3바이트, 4바이트를 사용함으로써 해결될 수 있다. uni-code 역시, uni-code 컨소시엄에서 정한, 바이트의 조합으로 구성된 문자이다(이모지 포함). 정확히는 이모지 역시 문자와 같은 바이트값이며, 이것의 폰트에 따라서 다른 이미지로 렌더링 될 뿐이다(알파벳 역시 폰트마다 다르게 렌더되는 것과 동일함).

그렇다면 여기서 피부색이 다른 emoji는 어떻게 구현했을까?
이전의 방식처럼 텍스트나 이메일을 통해 받는 첫 번째 바이트는 기본 노란색의 이모지 값을 보낸다.
그 다음 바이트값에 피부색조의 톤을 저장하여 보내는 것으로 해결한다. 5개의 피부톤이 있더라도, 5배 많은 값을 차지하지는 않지만 2배 많은 값을 차지한다. 이것은 reusable하다.
예를 들어 남자 + 하트 + 남자, 또는 여자 + 하트 + 여자 의 이모지가 각각 있다고 해보자.
이러한 이모지는 하나의 키로 매핑되어 있지만, 새롭게 만들어진 이모지는 아니다.
남자 이모지와 하트 이모지, 그리고 남자 이모지를 합쳐서 3가지 이모지를 재결합하여 만든 이모지로, 새롭게 생성된 이모지는 아니다. 즉 이모지는 결합될 수 있다(한글처럼).

RGB는 각각 픽셀을 나타내는 3바이트 값으로 구성되어 있으므로, 각각의 픽셀을 나타내야 하기 때문에 문자에 비해 용량이 매우 크다. 비디오는 알다싶이 이런 이미지들의 일련의 조합일 뿐이다.

오디오 파일에서 소리를 재생할때는 어떻게 나타낼까?
hertz, frequency로 나타내는 노트 뿐만 아니라, 음의 세기, 부드러움과 같은 척도로도 나타낼 수 있다.

이제 위의 PS에서 `black box`(abstraction)로 들어가보자.
abstraction은 무언가를 단순화하는 것을 의미하므로, low-level까지 들어갈 필요가 없다.
즉, 우리가 자동차를 운전한다면 우리는 목적지까지 가는 것을 목표로 하지, 기계적인 차의 움직임을 알 필요는 없다. 우리가 어딘가를 갈 때마다 기계적인 움직임을 알아야하고 입력해야 한다면 꽤나 복잡한 과정일 것이다. 추상화를 사용해보자.

- 미술적 추상화? 사물을 눈에 보이는 것처럼 자연적, 사실적으로 재현하는 것이 아니라, 점, 선, 면, 색채 등의 표현을 목표로 하는 그림 혹은 기법(<-> 구상화).
- 수학적 추상화? 엄밀함을 달성하는 방법.
- 컴퓨터 과학에서 추상화? 어떤 종류의 대상들에 대해 그것이 가져야 할 핵심적인 특징들을 가지는 모델을 만드는 것. abstraction layer를 살펴보자.
    1. specification: 추상화 계층의 아래쪽 구현 측면부터 살펴보면, 모델은 그에 해당하는 것을 구현할 때 그것이 어떤 특징들을 가지도록 만들어야 하는지에 대한 명세가 된다.
    2. interface: 추상화 계층의 위쪽 활용 측면에서 살펴보면, 우리는 이 모델에 해당하는 것의 특징들이 어떠한지 알고 있으므로, 모델은 대상이 내부에서 어떻게 동작하는지의 세부사항을 모르더라도 다른 것을 만들 때 활용할 수 있게끔 하는 인터페이스의 역할을 한다.

    우리가 메모리 공간을 가지고 간단한 프로그램을 만들 때, 그 메모리 공간이 플립플롭으로 만들어진 레지스터에 있는지 축전기로 만들어진 DRAM에 있는지에 상관없이 우리는 그 메모리 공간이 '어떤 시점에 값을 가지며, 그곳에 다른 값을 기록하지 않는 한 다음에도 계속 그 값을 유지'하는 특징을 가진다는 것을 알고 잇으므로 이를 활용하여 프로그램을 만들 수 있다. 심지어 그것이 일반적으로 생각하는 메인 메모리가 아니라 디스크 같은 곳에 있거나 아예 네트워크상의 어딘가에 있더라도 신경쓸 필요가 없다.

    마찬가지로, 명령어 집합 등 인터페이스 역할을 할 머신의 모델만 잘 정의되어 있으면, 그것이 실제 기계에서 돌아가는지, 아니면 소프트웨어적으로 시뮬레이트되는지에 상관없이 우리는 운영체제를 그 위에서 돌릴 수 있다. 이런 식으로 우리가 생각하는 실제 물리적 대상이 없어도 그 모델이 명세한 특징들을 가지도록 인터페이스만 만들어 놓으면 그것을 실제 대상인 것처럼 활용 가능한 가상화(virtualization)는 그 구현에 상관없이 그것을 활용할 수 있다는 추상화된 모델의 특징을 매우 잘 보여 주는 사례라 할 수 있겠다. 우리는 앞에서 설명한 추상화의 두 가지 측면을 이용하여 복잡한 구조의 어떤 부분을 만들 때 만약 그 부분이 가져야 할 특성들을 명세한 모델을 세워 놓았다면 그 세부사항의 구현과 그 부분을 활용하는 구현을 분리해 구현할 수 있다.

    더 일상적인 예시를 들자면, 음악이 나오는 웹 사이트를 만들 때 웹 사이트의 개발자는 브라우저에서 제공하는 소리가 나오게 만드는 HTML테그에 음악파일을 연결해주기만 하면 된다. 웹 개발자가 사용자의 컴퓨터의 환경을 알아내어 각 운영체제에 알맞는 오디오 출력 API를 호출할 필요가 없다. 이것은 브라우저에서 내부적으로 구현되어 있고 소리가 나게 만드는 HTML태그가 실행되면 그 코드가 실행되도록 브라우저 엔진이 만들어졌기 때문이다. 그리고 브라우저의 개발자도 오디오 장치가 Realtek인지 Creative인지 Nvidia인지 아니면 아예 컴퓨터 주인이 원격 데스크톱을 사용하고 있거나 트위치에 방송을 하고 있는지 등을 신경쓸 필요 없이 운영체제의 오디오 API만 호출하면 기본 출력 장치로 소리가 나게 만들 수 있다. 운영체제 내부적으로 장치 드라이버를 참조하여 하드웨어로 오디오를 출력하는 것이 구현되어 있기 때문. 심지어는 운영체제 개발자도 추상화된 드라이버 규격만 지정해두면 그 규격에 맞추어 하드웨어 제조사(Realtek, Creative, Nvidia 등)에서 드라이버를 만들기 때문에 운영체제 개발자도 오디오 장치를 제어하는 것에 신경 쓸 필요가 없다. 또한 추상화가 세부적인 것을 개발자가 신경쓸 필요가 없게 만들어 주기도 하지만 하위 계층을 직접 사용할수 없게 만들기도 한다. 예를 들면 웹 사이트의 개발자는 오디오와 관련된 네이티브 코드를 호출할수 없고 브라우저의 개발자는 오디오 하드웨어를 제어하는 코드를 사용할수 없다. 만약 추상화가 각 계층에서 전혀 이루어지지 않았다면 웹 사이트 개발자가 하드웨어를 제어하는 민감한 코드에 접근할 수 있게 해야하므로 시스템 안정성이 떨어지고 보안상 위험해진다.[3] 이렇게 추상화를 통해 샌드박스 환경을 구현하기도 한다.

우리는 위의 `black box`를 알고리즘이라고 부른다. 어떤 문제를 해결하기 위한 단계별 지침이다. ([abdul bari](https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O)교수의 알고리즘 참고)
divide-and-conquer & bisec 알고리즘(lg n)

pseudocode(의사코드로 의미론적으로 통용된 언어로 아이디어의 outline을 적기위해 사용)를 사용해서 모든 시나리오를 고려해서 개요를 시퀜셜하게 정리하기.

동사(do something, some action or verb) => function
조건 분기 = conditional
boolean expression = conditional의 조건이 성립 or true/false, yes/no, 1/0
indent = scope
loop,

terminology와 semantic, reuseable, consistency 등을 고려해서 아름다운 design을 설계. 함수는 그 자체로 추상화이므로 직관적이고 핸들링하기 쉽게 구현하기.