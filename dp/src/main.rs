fn main() {
    println!("큰 문제를 작은 문제로 쪼개서 해결한다. Divide-and-Conquer라는 원리에 기반을 두고\n\
    이전에 계산해둔 값을 메모리에 저장해서 반복작업을 줄이는 기법(Memoization)이 핵심이다.\n\
    예를 들면 중복되는 계산을 하지 않기 위해 이미 했던 계산의 값을 메모리에 저장해둬 중복 계산을 하지 않는 방식이다.\n\
    \
    \
    어떠한 문제를 dp로 풀기 위해서는 '최적의 원리(Principle of Optimality)'가 성립하는지를 확인해야 하는데, 최적의 원리란 다음과 같다.\n\
    '어떤 문제의 입력사례의 최적해가 그 입력사례를 분할한 부분사례에 대한 최적해를 항상 포함하고 있으면, 그 문제에 대하여\n\
    최적의 원리가 성립한다 - Richard Bellman.\n\
    https://gsmesie692.tistory.com/113\n\
    최적의 경로는 초기 조건과 초기 변수(선택)가 무엇이든간에 선택한 컨트롤(또는 결정 변수) 남은 기간에 걸친 문제는\n\
    나머지 문제에 대해 최적이어야하며 조기 결정으로 인한 상태가 초기 조건이되어야 한다.\n\
    예를 들어 node[a, ... , p]중에 a -> b -> c -> h -> p 가 최적의 경로라고 해보자.\n\
    그렇다면 a와 p를 뺀 b -> c -> h의 경로도 b에서 h까지 가는 최적의 경로이다.\n\
    https://pasus.tistory.com/127");
}
